#include "stdio.h"
#include "stdlib.h"
#include "math.h"

// Цифровой корень из числа равен остатку от деления на 9, и равен 9 в случае, если делится на 9. В дальнейшем я говорю, что он равен остатку, так как работаю с простыми числами, а они не делятся на 9.

int digitalRoot(int n) 
{
	if (n % 9 == 0)
	{
		return 9;
	}
	else
	{
		return (n % 9);
	}
}

int sumRoot(int *a) 
{
	/* На вход подается массив, содержаещий количество разных цифровых корней из простых множетилей числа на индексе,
	сответствующему значению, меньшему на один: Например, в a[2] находится число цифровых корней, равным трем.
	Так как цифровой корень - это остаток деления на 9, то максимальную сумму цифровых корней мы получим складывая остатки,
	для этого разложим число на простые  множетели, они дают определенные остатки (6 и 9 не дают, так как иначе они бы делились на три), 
	и скомбинируем максимальные остатки. Домножая числа между собой, их остатки будут также домножаться.
	Обычной проверкой видно, что остатки 5 и выше не надо домножать на другие, иначе сумма остатков будет меньше. Тоже самое с единицей.
	Комбиникем остатки 2, 3 и 4 следующим образом:
	Первым делом берем все пары 3, получая 9; потом пары 2 и 4, получем 8; затем оставшиеся троки 2, получем 8;
	Потом оставшуюся пару 2 и 3, затем прочто оставшиеся 4, 3 и 2 в обычном виде. Так получатся множетели, сумма цифровых корней которых максимальна.
	На примере из условия: 24 = 2 * 2 * 2 * 3 , множетели дают 3 остатка 2 и один 3, a[1] = 3, a[2] = 1;
	Тогда получим по порядку приоритета комбинации: 2 * 2 * 2 = 8 и 3, соответственно нужные множетели 3 и 8
	MDRS(24) = 11;
	*/
	int sum = 0;
	sum += a[7] * 8     
		 + a[6] * 7
	     + a[4] * 5
		 + (a[2] / 2) * 9
		 + a[0] * 1;
	if (a[3] < a[1]) // Здесь происходят комбинации в нужнои приоритете в зависимости от количества множетелей с остатками 2 и 4.
	{
		if ((a[1] - a[3]) % 3 > 0)
		{
			sum += a[3] * 8
				 + ((a[1] - a[3]) / 3) * 8 
				 + (a[2] % 2) * 6 
				 + (((a[1] - a[3]) % 3) - (a[2] % 2)) * 2;
		}
		else
		{
			sum += a[3] * 8
				 + ((a[1] - a[3]) / 3) * 8
				 + (a[2] % 2) * 3;
		}
	}
	else
	{
		if (a[3] > a[1])
		{
			sum += a[1] * 8
				 + (a[3] - a[1]) * 4
				 + (a[2] % 2) * 3;
		}
		else
		{
			sum += a[1] * 8
				 + (a[2] % 2) * 3;
		}
	}
	return sum;
}

int main()
{
	int a[8];
	int sum = 0;
	int *simpleNumber;
	int k = 1, i = 3, simple = 0;
	simpleNumber = (int*)malloc(k * sizeof(int));
	simpleNumber[0] = 2;
	k++;
	do // Цикл заполнения массива простыми числами до 1000000.
	{
		while (simple == 0)
		{
			int j = 0;
			do
			{
				if (i % simpleNumber[j] == 0)
				{
					simple = 0;
					break;
				}
				else
				{
					simple = 1;
				}
				j++;
			}
			while (simpleNumber[j] < sqrt(i));
			i++;
		}
		simpleNumber = (int*)realloc(simpleNumber, k * sizeof(int));
		simpleNumber[k - 1] = i - 1;
		k++;
		simple = 0;
	}
	while (i < 1000000);

	k--;
	k--;
	for (i = 2; i < 1000000; i++) 
	{
		/* В этом цикле каждое число раскладывается на простые множетели, 
	     записывается в массив количество определенных остатков этих чисел 
		 и по этому массиву к общей сумме прибавляется MDRS этого числа.
		*/
		for (int j = 0; j < 9; j++)
		{
			a[j] = 0;
		}
		int n = i;
		int j = 0;
		while (n != 1)
		{
			if (simpleNumber[j] > sqrt(n))
			{
				a[digitalRoot(n) - 1]++;
				n = 1;
			}
			else
			{
				if (n % simpleNumber[j] == 0)
				{
					n /= simpleNumber[j];
					a[digitalRoot(simpleNumber[j]) - 1]++;
				}
				else
				{
					j++;
				}
			}
		}
		sum += sumRoot(a);
	}

	printf("Summ MDRS(n) = %d", sum);

	_getch();

	return 0;
}